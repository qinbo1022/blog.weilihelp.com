<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bobo的鬼屋</title>
  <icon>https://www.gravatar.com/avatar/bf7dad1a28723440e66577cf9bf349f6</icon>
  <subtitle>我单手握着方向盘没跟谁比赛</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="//blog.qinbo.top/"/>
  <updated>2020-06-05T11:54:25.008Z</updated>
  <id>//blog.qinbo.top/</id>
  
  <author>
    <name>bobo</name>
    <email>qinbo1022@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《小狗钱钱》读后总结</title>
    <link href="//blog.qinbo.top/2020/06/05/%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1%E8%AF%BB%E5%90%8E%E6%80%BB%E7%BB%93/"/>
    <id>//blog.qinbo.top/2020/06/05/小狗钱钱读后总结/</id>
    <published>2020-06-05T06:41:35.000Z</published>
    <updated>2020-06-05T11:54:25.008Z</updated>
    
    <content type="html"><![CDATA[<p>《小狗钱钱》讲的是故事，是理财，也是人生。</p><p>【梦想存储罐和梦想相册】：</p><ol><li>界定范围，让梦想在可及范围</li><li>自我激励，让未来触手可及</li><li>积跬步至千里，保持梦想鲜活度</li></ol><p>【达瑞与表哥的故事】：</p><ol><li>发现并抓住身边的机会</li><li>不要因为客观因素忘了需要坚持的事情</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《小狗钱钱》讲的是故事，是理财，也是人生。&lt;/p&gt;
&lt;p&gt;【梦想存储罐和梦想相册】：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;界定范围，让梦想在可及范围&lt;/li&gt;
&lt;li&gt;自我激励，让未来触手可及&lt;/li&gt;
&lt;li&gt;积跬步至千里，保持梦想鲜活度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【达瑞与表哥的
      
    
    </summary>
    
    
      <category term="读后感" scheme="//blog.qinbo.top/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>【ip地址、子网掩码、网关地址】浅析</title>
    <link href="//blog.qinbo.top/2020/06/05/%E3%80%90ip%E5%9C%B0%E5%9D%80%E3%80%81%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E3%80%81%E7%BD%91%E5%85%B3%E5%9C%B0%E5%9D%80%E3%80%91%E6%B5%85%E6%9E%90/"/>
    <id>//blog.qinbo.top/2020/06/05/【ip地址、子网掩码、网关地址】浅析/</id>
    <published>2020-06-05T05:59:39.000Z</published>
    <updated>2020-06-05T06:00:21.692Z</updated>
    
    <content type="html"><![CDATA[<p>1）IP地址</p><p>IP地址是TCP/IP协议为了唯一地确定一台主机的位置所定义的地址。</p><p>IP地址有效范围分为五类，A类保留给政府机构，B类分配给中等规模的公司，C类分配给任何需要的人，D类用于组播，E类用于实验：</p><ol><li><p>A类地址<br>⑴ A类地址第1字节为网络地址，其它3个字节为主机地址。<br>⑵ A类地址范围：<strong>1.0.0.1—126.155.255.254</strong><br>⑶ A类地址中的私有地址和保留地址：<br>① <strong>10.X.X.X</strong>是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址）。<br>② <strong>127.X.X.X</strong>是保留地址，用做循环测试用的。</p></li><li><p>B类地址<br>⑴ B类地址第1字节和第2字节为网络地址，其它2个字节为主机地址。<br>⑵ B类地址范围：<strong>128.0.0.1—191.255.255.254</strong>。<br>⑶ B类地址的私有地址和保留地址<br>① <strong>172.16.0.0—172.31.255.255</strong>是私有地址<br>② <strong>169.254.X.X</strong>是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器。就会得到其中一个IP。</p></li><li><p>C类地址<br>⑴ C类地址第1字节、第2字节和第3个字节为网络地址，第4个个字节为主机地址。另外第1个字节的前三位固定为110（二进制）。<br>⑵ C类地址范围：<strong>192.0.0.1—223.255.255.254</strong>。<br>⑶ C类地址中的私有地址：<strong>192.168.X.X</strong>是私有地址。</p></li><li><p>D类地址<br>⑴ D类地址不分网络地址和主机地址，它的第1个字节的前四位固定为1110（二进制）。<br>⑵ D类地址范围：<strong>224.0.0.1—239.255.255.254</strong></p></li><li><p>E类地址<br>⑴ E类地址也不分网络地址和主机地址，它的第1个字节的前五位固定为11110（二进制）。<br>⑵ E类地址范围：<strong>240.0.0.1—255.255.255.254</strong></p></li></ol><p>2）子网掩码</p><p>子网掩码的作用是屏蔽部分ip地址和区分主机标识和网络标识，必须与IP一起使用，使用子网掩码可减少IP的浪费。</p><p>子网掩码是一串32位的二进制数字，由连续的1和连续的0组成，与IP一起使用，每一位都是对应关系，做&amp;运算，左边是网络位，由1组成，1的数量代表着网络位的长度，右边是主机位由0组成，0的数目即为主机位的长度。在与IP做与运算（&amp;）时，0可以遮住主机地址（&amp;运算，见下方）以达到屏蔽部分ip的目的。常用三类IP地址都有缺省子网掩码：</p><table><thead><tr><th>类别</th><th>子网掩码的二进制数值</th><th>子网掩码的十进制数值</th></tr></thead><tbody><tr><td>A</td><td>11111111 00000000 00000000 00000000</td><td>255.0.0.0</td></tr><tr><td>B</td><td>11111111 11111111 00000000 00000000</td><td>255.255.0.0</td></tr><tr><td>C</td><td>11111111 11111111 11111111 000000000</td><td>255.255.255.0</td></tr></tbody></table><p><strong>两台计算机的IP地址与子网掩码做&amp;运算后，得出的网络位如果相同，则这两台计算机处于同一子网（网段）</strong></p><p>企业可通过划分多个子网来解决ip资源不足的问题，但多个子网之间的通信则需要通过<strong>网关</strong>进行连接。</p><p>3）网关</p><p>网关是一种充当网络转换的计算机系统或设备，可以将不同的通信协议、数据格式或语言，乃至体系结构完全不同的两种系统之间进行翻译与转换，转换后的信息重新打包后通过网桥或交换机进行传达，以实现不同的网络互联，它的实质是一个网络通向另一个网络的IP地址。</p><p>通过上面的描述我们知道，是否同一网段是通过子网掩码和IP地址运算进行判定的，当两个网络之间没有路由器，是不可以进行TCP/IP协议通信的，要实现互通就必须通过网关，例如A网络与B网络不互通，如果A网络的主机发现目标主机不在本网络，他就把数据发送到自己的网关，再由网关转发给B网络的网关，B网络的网关再将数据发送给B网络的主机，在此过程中网关充当了路由器的角色，故也被称为“IP路由器”。</p><p>与运算规则：1&amp;1=1，0&amp;1=0，0&amp;0=0，即全1则得1，不全1则得0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1）IP地址&lt;/p&gt;
&lt;p&gt;IP地址是TCP/IP协议为了唯一地确定一台主机的位置所定义的地址。&lt;/p&gt;
&lt;p&gt;IP地址有效范围分为五类，A类保留给政府机构，B类分配给中等规模的公司，C类分配给任何需要的人，D类用于组播，E类用于实验：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A类
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="//blog.qinbo.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Google缓存框架GuavaCache</title>
    <link href="//blog.qinbo.top/2020/06/05/Google%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6GuavaCache/"/>
    <id>//blog.qinbo.top/2020/06/05/Google缓存框架GuavaCache/</id>
    <published>2020-06-05T05:56:14.000Z</published>
    <updated>2020-06-05T05:57:09.553Z</updated>
    
    <content type="html"><![CDATA[<h3 id="what、why、how三部曲"><a href="#what、why、how三部曲" class="headerlink" title="what、why、how三部曲"></a>what、why、how三部曲</h3><h4 id="1-GuavaCache是什么？"><a href="#1-GuavaCache是什么？" class="headerlink" title="1.GuavaCache是什么？"></a>1.GuavaCache是什么？</h4><p>GuavaCache是Guava中的缓存框架，与ConcurrentMap很相似，不一样的是，ConcurrentMap中的元素会一直保留直到显式的移除，而GuavaCache为了限制内存占用，通常会设定为自动回收元素。</p><h4 id="2-什么时候用GuavaCache"><a href="#2-什么时候用GuavaCache" class="headerlink" title="2.什么时候用GuavaCache?"></a>2.什么时候用GuavaCache?</h4><p>与传统的缓存方案相比，如redis，GuavaCache是将数据放在内存当中，访问起来更加高效，并且GuavaCache将很多常见的业务场景进行高度封装，使用起来非常灵活，对内存中的数据管理也有更多的方案。<br>    Guava官网介绍，下面的这几种情况可以考虑使用Guava Cache：</p><pre><code>- 愿意消耗一些内存空间来提升速度。- 预料到某些键会被多次查询。- 缓存中存放的数据总量不会超出内存容量。</code></pre><h4 id="3-如何使用GuavaCache？"><a href="#3-如何使用GuavaCache？" class="headerlink" title="3.如何使用GuavaCache？"></a>3.如何使用GuavaCache？</h4><h5 id="1-构建缓存对象"><a href="#1-构建缓存对象" class="headerlink" title="1. 构建缓存对象"></a>1. 构建缓存对象</h5><p> 可以通过CacheBuilder类构建一个缓存对象，CacheBuilder采用builder设计模式，它的每个方法都返回CacheBuilder本身，直到build()方法被调用。构建一个对象的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build();</span><br><span class="line">    cache.put(<span class="string">"hello"</span>, <span class="string">"hello world"</span>);</span><br><span class="line">    System.out.println(cache.getIfPresent(<span class="string">"hello"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-设置最大存储量"><a href="#2-设置最大存储量" class="headerlink" title="2. 设置最大存储量"></a>2. 设置最大存储量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().maximumSize(<span class="number">3</span>).build();</span><br><span class="line">    cache.put(<span class="string">"hello"</span>, <span class="string">"hello world"</span>);</span><br><span class="line">    System.out.println(cache.getIfPresent(<span class="string">"hello"</span>));</span><br><span class="line">    cache.put(<span class="string">"hello1"</span>, <span class="string">"hello world1"</span>);</span><br><span class="line">    cache.put(<span class="string">"hello2"</span>, <span class="string">"hello world2"</span>);</span><br><span class="line">    cache.put(<span class="string">"hello3"</span>, <span class="string">"hello world3"</span>);</span><br><span class="line">    System.out.println(cache.getIfPresent(<span class="string">"hello"</span>));</span><br><span class="line">    System.out.println(cache.getIfPresent(<span class="string">"hello1"</span>));</span><br><span class="line">    System.out.println(cache.getIfPresent(<span class="string">"hello2"</span>));</span><br><span class="line">    System.out.println(cache.getIfPresent(<span class="string">"hello3"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>hello worldnullhello world1hello world2hello world3</code></pre><h5 id="3-设置过期时间"><a href="#3-设置过期时间" class="headerlink" title="3. 设置过期时间"></a>3. 设置过期时间</h5><p> <strong>expireAfterWrite</strong>是设置put到Cache的对象3秒过期，不论中间有没有被访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCache</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">   Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().expireAfterWrite(<span class="number">3</span>, TimeUnit.SECONDS).maximumSize(<span class="number">3</span>).build();</span><br><span class="line">   cache.put(<span class="string">"hello"</span>, <span class="string">"hello world"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">        System.out.println(<span class="string">"第"</span>+i+<span class="string">"次获取key的值："</span>+ cache.getIfPresent(<span class="string">"hello"</span>));</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>第0次获取key的值：hello world第1次获取key的值：hello world第2次获取key的值：hello world第3次获取key的值：null第4次获取key的值：null第5次获取key的值：null第6次获取key的值：null</code></pre><p><strong>expireAfterAccess</strong>是设置Cache中对象超过3秒没有被访问就会过期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCache</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">   Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().expireAfterAccess(<span class="number">3</span>, TimeUnit.SECONDS).maximumSize(<span class="number">3</span>).build();</span><br><span class="line">    cache.put(<span class="string">"hello"</span>, <span class="string">"hello world"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"第"</span> + i + <span class="string">"秒获取key的值："</span> + cache.getIfPresent(<span class="string">"hello"</span>));</span><br><span class="line">        Thread.sleep(i * <span class="number">1000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>第0秒获取key的值：hello world第1秒获取key的值：hello world第2秒获取key的值：hello world第3秒获取key的值：hello world第4秒获取key的值：null第5秒获取key的值：null第6秒获取key的值：null</code></pre><h5 id="4-显示清除"><a href="#4-显示清除" class="headerlink" title="4. 显示清除"></a>4. 显示清除</h5><p> 可以调用Cache的invalidateAll批量移除记录或者调用invalidate移除Cache中的一个记录，invalidateAll的参数是Iterable类型的，参数包含要删除的key值，当没有传入任何参数时，invalidateAll将移除Cache中所有的记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build();</span><br><span class="line">    cache.put(<span class="string">"hello1"</span>,<span class="string">"world1"</span>);</span><br><span class="line">    cache.put(<span class="string">"hello2"</span>,<span class="string">"world2"</span>);</span><br><span class="line">    cache.put(<span class="string">"hello3"</span>,<span class="string">"world3"</span>);</span><br><span class="line">    cache.put(<span class="string">"hello4"</span>,<span class="string">"world4"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cache.invalidate("hello2");</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"hello2"</span>);</span><br><span class="line">    list.add(<span class="string">"hello3"</span>);</span><br><span class="line"></span><br><span class="line">    cache.invalidateAll(list);</span><br><span class="line">    System.out.println(cache.getIfPresent(<span class="string">"hello1"</span>));</span><br><span class="line">    System.out.println(cache.getIfPresent(<span class="string">"hello2"</span>));</span><br><span class="line">    System.out.println(cache.getIfPresent(<span class="string">"hello3"</span>));</span><br><span class="line">    System.out.println(cache.getIfPresent(<span class="string">"hello4"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>world1nullnullworld4</code></pre><h5 id="5-移除监听器"><a href="#5-移除监听器" class="headerlink" title="5. 移除监听器"></a>5. 移除监听器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">RemovalListener&lt;String, String&gt; listener = removalNotification -&gt; System.out.println(removalNotification.getKey()</span><br><span class="line">        + <span class="string">":"</span> + removalNotification.getValue() + <span class="string">" is removed"</span>);</span><br><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().removalListener(listener).maximumSize(<span class="number">3</span>).build();</span><br><span class="line">cache.put(<span class="string">"hello1"</span>, <span class="string">"world1"</span>);</span><br><span class="line">cache.put(<span class="string">"hello2"</span>, <span class="string">"world2"</span>);</span><br><span class="line">cache.put(<span class="string">"hello3"</span>, <span class="string">"world3"</span>);</span><br><span class="line">cache.put(<span class="string">"hello4"</span>, <span class="string">"world4"</span>);</span><br><span class="line">cache.put(<span class="string">"hello5"</span>, <span class="string">"world5"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>hello1:world1 is removedhello2:world2 is removed</code></pre><p>以上列举了GuavaCache常用几种方法，源码请移步下方地址获取：</p><blockquote><p><a href="https://github.com/google/guava" target="_blank" rel="noopener">https://github.com/google/guava</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;what、why、how三部曲&quot;&gt;&lt;a href=&quot;#what、why、how三部曲&quot; class=&quot;headerlink&quot; title=&quot;what、why、how三部曲&quot;&gt;&lt;/a&gt;what、why、how三部曲&lt;/h3&gt;&lt;h4 id=&quot;1-GuavaCache是
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="//blog.qinbo.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Guava" scheme="//blog.qinbo.top/tags/Guava/"/>
    
  </entry>
  
  <entry>
    <title>React学习-day02</title>
    <link href="//blog.qinbo.top/2020/06/03/React%E5%AD%A6%E4%B9%A0-day02/"/>
    <id>//blog.qinbo.top/2020/06/03/React学习-day02/</id>
    <published>2020-06-03T05:40:40.000Z</published>
    <updated>2020-06-03T11:41:17.407Z</updated>
    
    <content type="html"><![CDATA[<p>React学习day02。</p><a id="more"></a><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ol><li>事件处理方式</li><li>条件渲染过程</li><li>实战训练</li></ol><h3 id="React事件处理"><a href="#React事件处理" class="headerlink" title="React事件处理"></a>React事件处理</h3><p>元素的事件处理方式与dom元素事件处理类似，语法上有一点不同：</p><ul><li>React事件的命名采用小驼峰(camelCase)</li><li>使用JSX标签语法，需要传入一个函数作为处理函数，如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><h4 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h4><p>在react的事件处理中，如果需要阻止默认行为，需要显式的调用<code>e.preventDefault();</code>方法，而不是用传统的<code>return false;</code>的方式。例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function ActionLink() &#123;</span><br><span class="line">  function handleClick(e) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    console.log(&apos;The link was clicked.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;a href=&quot;#&quot; onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加监听器"><a href="#添加监听器" class="headerlink" title="添加监听器"></a>添加监听器</h4><p>使用 React 时，你一般不需要使用 <code>addEventListener</code> 为已创建的 DOM 元素添加监听器。事实上，你只需要在该元素初始渲染的时候添加监听器即可。 </p><h4 id="This二三问"><a href="#This二三问" class="headerlink" title="This二三问"></a>This二三问</h4><p>先看一个案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Toggle extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;isToggleOn: true&#125;;</span><br><span class="line"></span><br><span class="line">    // 为了在回调中使用 `this`，这个绑定是必不可少的</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    this.setState(state =&gt; (&#123;</span><br><span class="line">      isToggleOn: !state.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">        &#123;this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Toggle /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>快速概括一下页面渲染过程：</p><p>1.当<code>&lt;Toggle /&gt;</code>被传给<code>ReactDOM.render()</code>时，React会调用Toggle的构造函数。在构造函数中我们为<code>state</code>赋了初始值，并且手动将this传入了函数<code>handleClick</code>。</p><p>2.之后React会调用<code>render()</code>方法。这个方法会渲染UI，页面中插入一个<code>button</code>，<code>button</code>的文字是由state确定的，此时为初始化的<code>ture</code>。</p><p>3.当用户点击这个button的时候，会触发点击事件，button上绑定的点击事件是<code>handleClick()</code>方法，在这个方法中Toggle方法会通过<code>setState()</code>来更改state的值，此时React已经知道state的值改变了，就会重新调用<code>render()</code>方法来渲染页面。</p><p><strong>Q1:为什么要在构造方法中为handleClick赋值？</strong></p><p><strong>A1:</strong>如果初始化的时候没有为handleClick赋This的值，那么在用户点击按钮调用handleClick方法时，得到的This是undefined，而赋值实际的作用是将state传入到回调函数。</p><p><strong>Q2:我可以在调用时为其赋值吗？</strong></p><p><strong>A2:</strong>可以，你可以写成<code>onClick={this.handleClick.bind(this)</code>。</p><h4 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h4><p>在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 <code>id</code> 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;</span><br><span class="line">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>上述两种方式是等价的，分别通过<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener"><code>Function.prototype.bind</code></a> 来实现。</p><p>在这两种情况下，React 的事件对象 <code>e</code> 会被作为<strong>第二个</strong>参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React学习day02。&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="//blog.qinbo.top/tags/React/"/>
    
      <category term="学习笔记" scheme="//blog.qinbo.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>React学习 - day1</title>
    <link href="//blog.qinbo.top/2020/06/02/React%E5%AD%A6%E4%B9%A0-day01/"/>
    <id>//blog.qinbo.top/2020/06/02/React学习-day01/</id>
    <published>2020-06-02T02:51:45.000Z</published>
    <updated>2020-06-02T10:23:24.016Z</updated>
    
    <content type="html"><![CDATA[<p>React学习day01。</p><a id="more"></a><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ol><li>JSX概念</li><li>元素渲染</li><li>组件 &amp; props 概念</li><li>State &amp; 生命周期 概念</li></ol><h3 id="JSX的概念"><a href="#JSX的概念" class="headerlink" title="JSX的概念"></a>JSX的概念</h3><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</span><br></pre></td></tr></table></figure><p>这种标签语法是Javascript的扩展语法，被称之为JSX，它可以描述出UI被渲染的本质形式，不属于React，但建议在React中使用它。</p><h4 id="React为什么用JSX？"><a href="#React为什么用JSX？" class="headerlink" title="React为什么用JSX？"></a>React为什么用JSX？</h4><p> React 并没有采用将<u>标记与逻辑进行分离到不同文件</u>这种人为地分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现<a href="[https://zh.wikipedia.org/wiki/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB](https://zh.wikipedia.org/wiki/关注点分离"><em>关注点分离</em></a> )。 </p><h4 id="在-JSX-中嵌入表达式"><a href="#在-JSX-中嵌入表达式" class="headerlink" title="在 JSX 中嵌入表达式"></a>在 JSX 中嵌入表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const name = &apos;BOBO&apos;;</span><br><span class="line">const element = &lt;h1&gt;Hello, &#123;name&#125;&lt;/h1&gt;;</span><br></pre></td></tr></table></figure><p> 在 JSX 语法中，你可以在大括号内放置任何有效的Javascript表达式。 例如，<code>2 + 2</code>，<code>user.firstName</code> 或 <code>formatName(user)</code> 都是有效的 JavaScript 表达式。 </p><h4 id="JSX的特定属性"><a href="#JSX的特定属性" class="headerlink" title="JSX的特定属性"></a>JSX的特定属性</h4><p>你可以通过使用引号，来将属性值指定为字符串字面量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;;</span><br></pre></td></tr></table></figure><p>也可以使用大括号，来在属性值中插入一个 JavaScript 表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;;</span><br></pre></td></tr></table></figure><p> 在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号。你应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个，对于同一属性不能同时使用这两种符号。 </p><p>假如一个标签里面没有内容，你可以使用 <code>/&gt;</code> 来闭合标签，就像 XML 语法一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;;</span><br></pre></td></tr></table></figure><p>JSX 标签里能够包含很多子元素:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;Good to see you here.&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="JSX渲染对象"><a href="#JSX渲染对象" class="headerlink" title="JSX渲染对象"></a>JSX渲染对象</h4><p>Babel 会把 JSX 转译成一个名为 <code>React.createElement()</code> 函数调用。</p><p>以下两种示例代码完全等效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const element = (</span><br><span class="line">  &lt;h1 className=&quot;greeting&quot;&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">);</span><br><span class="line">const element = React.createElement(</span><br><span class="line">  &apos;h1&apos;,</span><br><span class="line">  &#123;className: &apos;greeting&apos;&#125;,</span><br><span class="line">  &apos;Hello, world!&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>React.createElement()</code> 会预先执行一些检查，以帮助你编写无错代码，但实际上它创建了一个这样的对象【虚拟Dom树】：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 这是简化过的结构</span><br><span class="line">const element = &#123;</span><br><span class="line">  type: &apos;h1&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: &apos;greeting&apos;,</span><br><span class="line">    children: &apos;Hello, world!&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些对象被称为 “React 元素”，实际上就是一个json对象。它们描述了你希望在屏幕上看到的内容，将每一个下级元素以json的子类表示出来。React 通过读取这些对象，然后使用它们来构建 DOM 以及保持随时更新。</p><h3 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h3><p>元素定义：元素是构成react的最小单位，组件是由元素构成的。</p><h4 id="将元素渲染成一个DOM"><a href="#将元素渲染成一个DOM" class="headerlink" title="将元素渲染成一个DOM"></a>将元素渲染成一个DOM</h4><p>想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 <code>ReactDOM.render()</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</span><br><span class="line">ReactDOM.render(element, document.getElementById(&apos;root&apos;));</span><br></pre></td></tr></table></figure><h4 id="更新已被渲染的元素"><a href="#更新已被渲染的元素" class="headerlink" title="更新已被渲染的元素"></a>更新已被渲染的元素</h4><p>React 元素是不可变对象。一旦被创建，就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。</p><p>根据我们已有的知识，更新 UI 唯一的方式是创建一个全新的元素，并将其传入 <code>ReactDOM.render()</code>。</p><blockquote><p><strong>注意：</strong> 在实践中，大多数 React 应用只会调用一次 <code>ReactDOM.render()</code>。</p></blockquote><p>React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。 </p><p>尽管每一秒我们都会新建一个描述整个 UI 树的元素，React DOM 只会更新实际改变了的内容。 </p><h3 id="组件-amp-props"><a href="#组件-amp-props" class="headerlink" title="组件 &amp; props"></a>组件 &amp; props</h3><blockquote><p> 组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。 </p></blockquote><p>组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。 </p><h4 id="组件定义方式"><a href="#组件定义方式" class="headerlink" title="组件定义方式"></a>组件定义方式</h4><p>1.函数式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Welcome(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.class式【ES6写法】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Welcome extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种方式是等效的。</p><h4 id="自定义组件及渲染方式"><a href="#自定义组件及渲染方式" class="headerlink" title="自定义组件及渲染方式"></a>自定义组件及渲染方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Welcome(props) &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p> 当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。 </p><h4 id="组件拆分提取"><a href="#组件拆分提取" class="headerlink" title="组件拆分提取"></a>组件拆分提取</h4><p><strong>Question：为什么要提取组件？什么情况下提取组件？</strong></p><p>Answer1： 提取组件可能是一件繁重的工作，但是，在大型应用中，构建可复用组件库是完全值得的。</p><p>Answer2： 根据经验来看，如果 UI 中有一部分被多次使用（<code>Button</code>，<code>Panel</code>，<code>Avatar</code>），或者组件本身就足够复杂（<code>App</code>，<code>FeedStory</code>，<code>Comment</code>），那么它就是一个可复用组件的候选项。 </p><p>案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Comment(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;Comment&quot;&gt;</span><br><span class="line">      &lt;div className=&quot;UserInfo&quot;&gt;</span><br><span class="line">        &lt;img className=&quot;Avatar&quot;</span><br><span class="line">          src=&#123;props.author.avatarUrl&#125;</span><br><span class="line">          alt=&#123;props.author.name&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;div className=&quot;UserInfo-name&quot;&gt;</span><br><span class="line">          &#123;props.author.name&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=&quot;Comment-text&quot;&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=&quot;Comment-date&quot;&gt;</span><br><span class="line">        &#123;formatDate(props.date)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该组件用于描述一个社交媒体网站上的评论功能，它接收 <code>author</code>（对象），<code>text</code> （字符串）以及 <code>date</code>（日期）作为 props。 </p><p>在这个组件中，人员信息是可被复用的，而人员信息中的头像信息也是可以复用的，所以这里我们将这两部分提取出来。</p><blockquote><p>通常来说，每个新的 React 应用程序的顶层组件都是 <code>App</code> 组件。但是，如果你将 React 集成到现有的应用程序中，你可能需要使用像 <code>Button</code> 这样的小组件，并自下而上地将这类组件逐步应用到视图层的每一处。 </p></blockquote><p>根据自下而上的原则，我们先提取头像组件<code>Avatar</code>组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Avatar(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;img className=&quot;Avatar&quot;</span><br><span class="line">      src=&#123;props.user.avatarUrl&#125;</span><br><span class="line">      alt=&#123;props.user.name&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继而提取人员信息<code>UserInfo</code>组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function UserInfo(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;UserInfo&quot;&gt;</span><br><span class="line">      &lt;Avatar user=&#123;props.user&#125; /&gt;</span><br><span class="line">      &lt;div className=&quot;UserInfo-name&quot;&gt;</span><br><span class="line">        &#123;props.user.name&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，UserInfo组件是直接引用的Avatar组件。</p><p>简化后的<code>Comment</code>组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Comment(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;Comment&quot;&gt;</span><br><span class="line">      &lt;UserInfo user=&#123;props.author&#125; /&gt;</span><br><span class="line">      &lt;div className=&quot;Comment-text&quot;&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=&quot;Comment-date&quot;&gt;</span><br><span class="line">        &#123;formatDate(props.date)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Props-的只读性"><a href="#Props-的只读性" class="headerlink" title="Props 的只读性"></a>Props 的只读性</h4><p> 组件无论是使用函数声明还是通过 class 声明，都决不能修改自身的 props，React 非常灵活，但它也有一个严格的规则：</p><blockquote><p>所有 React 组件都必须像<strong>纯函数</strong>一样保护它们的 props 不被更改。</p></blockquote><p>纯函数的定义： 函数不会尝试更改入参，且多次调用下相同的入参始终返回相同的结果。 </p><p><strong>引申问题</strong>：应用程序的 UI 是动态的，并会伴随着用户操作而不断变化，那么怎么实现在props不被更改的情况下实现动态刷新？</p><h3 id="State-amp-生命周期"><a href="#State-amp-生命周期" class="headerlink" title="State &amp; 生命周期"></a>State &amp; 生命周期</h3><p>state是局部变量，依赖于class组件，在构造函数中为state赋初始值。</p><p>调用 <code>this.setState()</code> 来可以进行一次 UI 更新， 得益于 <code>setState()</code> 的调用，React 能够知道 state 已经改变了，然后会重新调用 <code>render()</code> 方法来确定页面上该显示什么。 </p><p><strong>生命周期方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    //挂载</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">    //卸载</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当组件的输出被插入到 DOM 中后，React 就会调用 <code>ComponentDidMount()</code> 生命周期方法。 </p><p>当组件从 DOM 中被移除，React 就会调用 <code>componentWillUnmount()</code> 生命周期方法。</p><p><strong>State的更新会被合并</strong></p><p> 当你调用 <code>setState()</code> 的时候，React 会把你提供的对象合并到当前的 state。当要合并的属性已存在的时候，会直接覆盖，被完整替换。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React学习day01。&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="//blog.qinbo.top/tags/React/"/>
    
      <category term="学习笔记" scheme="//blog.qinbo.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之建造者模式（1/23）</title>
    <link href="//blog.qinbo.top/2020/05/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%881-23%EF%BC%89/"/>
    <id>//blog.qinbo.top/2020/05/29/设计模式之建造者模式（1-23）/</id>
    <published>2020-05-29T08:11:08.000Z</published>
    <updated>2020-05-29T11:37:12.064Z</updated>
    
    <content type="html"><![CDATA[<p>建造者模式浅析。</p><a id="more"></a><h2 id="一、what"><a href="#一、what" class="headerlink" title="一、what"></a>一、what</h2><p><strong>什么是建造者模式？</strong></p><blockquote><p> 造者模式(<code>Builder Pattern</code>)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式属于<strong>对象创建型模式</strong>。建造者模式又可以称为<strong>生成器模式</strong>。 </p></blockquote><h2 id="二、why"><a href="#二、why" class="headerlink" title="二、why"></a>二、why</h2><p><strong>为什么要用建造者模式?</strong></p><p>软件开发过程中，存在一些复杂的对象，它们拥有一系列成员属性，而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。 </p><p>这些情况的存在导致复杂对象初始化变得非常麻烦，于是建造者模式应运而生，建造者模式将复杂的构建过程封装起来，暴露出建造的动作， 用户无须关心该对象所包含的属性以及它们的组装方式，这就是为什么要使用建造者模式的原因。</p><h2 id="三、how"><a href="#三、how" class="headerlink" title="三、how"></a>三、how</h2><p><strong>如何使用？在什么情况下使用？</strong></p><p>带着问题开始阅读~</p><h4 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1.角色组成"></a>1.角色组成</h4><p>建造者模式包含以下角色：</p><ul><li>Builder: 抽象建造者</li><li>ConcreteBuilder：具体建造者</li><li>Director：导演者</li><li>Product：产品</li></ul><h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h4><p>a).场景模拟</p><p>现有一个需求，建造一栋乡间别墅，请到了一支建筑团队，这时的角色组成可以带入到建造者模式中：</p><p>产品：别墅</p><p>导演：包工头</p><p>抽象建造者：施工员</p><p>具体建造者：农民工</p><p>b).工作拆分</p><p>首先产品确定产品内容：</p><p>别墅在建造过程中分为四部分：</p><ol><li>打地基</li><li>筑墙</li><li>盖楼板</li><li>封顶</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">//打地基</span></span><br><span class="line">    <span class="keyword">private</span> String base;</span><br><span class="line">    <span class="comment">//墙壁</span></span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line">    <span class="comment">//楼板</span></span><br><span class="line">    <span class="keyword">private</span> String board;</span><br><span class="line">    <span class="comment">//封顶</span></span><br><span class="line">    <span class="keyword">private</span> String top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>施工员要画哪些图纸，也就是抽象建造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图纸</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">drawing</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建造地基</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildBase</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建造墙壁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建造楼板</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildBoard</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建造屋顶</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTop</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//验收产品</span></span><br><span class="line">    <span class="function">Product <span class="title">getResult</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>农名工建造的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建造者根据图纸内容建造，这里是复杂的构建过程，代码只是举例</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Drawing</span> </span>&#123;</span><br><span class="line">    Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"过程：采用xxx技术打造坚固的地基"</span>);</span><br><span class="line">        product.setBase(<span class="string">"地基"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"过程：采用xxx材料建起最好的墙壁"</span>);</span><br><span class="line">        product.setWall(<span class="string">"墙壁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBoard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"过程：采用xxx材料打造最厚实的楼板"</span>);</span><br><span class="line">        product.setBoard(<span class="string">"楼板"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"过程：采用xxx过程建造最好楼顶"</span>);</span><br><span class="line">        product.setTop(<span class="string">"楼顶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包工头的工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包工头</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Contractor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Drawing drawing;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，拿到图纸</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Contractor</span><span class="params">(Drawing drawing)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drawing = drawing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监督每个部分的建造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        drawing.buildBase();</span><br><span class="line">        drawing.buildBoard();</span><br><span class="line">        drawing.buildTop();</span><br><span class="line">        drawing.buildWall();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c).实际建造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//农民工拿到图纸</span></span><br><span class="line">        Drawing drawing = <span class="keyword">new</span> Worker();</span><br><span class="line">        <span class="comment">//包工头喊农名工兄弟过来</span></span><br><span class="line">        Contractor contractor = <span class="keyword">new</span> Contractor(drawing);</span><br><span class="line">        <span class="comment">//包工头开始指挥建造</span></span><br><span class="line">        contractor.construct();</span><br><span class="line">        <span class="comment">//建造完毕，拿到根据图纸产出的别墅</span></span><br><span class="line">        Product product = drawing.getResult();</span><br><span class="line">        log.info(<span class="string">"别墅地基：&#123;&#125;"</span>,product.getBase());</span><br><span class="line">        log.info(<span class="string">"别墅墙壁：&#123;&#125;"</span>,product.getWall());</span><br><span class="line">        log.info(<span class="string">"别墅楼板：&#123;&#125;"</span>,product.getBoard());</span><br><span class="line">        log.info(<span class="string">"别墅屋顶：&#123;&#125;"</span>,product.getTop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/qinbo1022/image_online/master/20200529181305.png" alt="建造结果"></p><p>对于客户来说他只需告诉包工头我要建什么样的别墅，就能得到结果，无需关注过程。</p><p>在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。</p><p>通过上面的案例我们可以得出大致的结论：</p><p>在以下情况下可以使用建造者模式：</p><ul><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li><li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;建造者模式浅析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="//blog.qinbo.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计原则与设计模式</title>
    <link href="//blog.qinbo.top/2020/05/27/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>//blog.qinbo.top/2020/05/27/设计原则与设计模式/</id>
    <published>2020-05-27T10:08:33.000Z</published>
    <updated>2020-05-28T10:52:47.451Z</updated>
    
    <content type="html"><![CDATA[<p>六大设计原则与二十三种设计模式。</p><a id="more"></a><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>设计模式是在软件工程实践过程中，程序员们总结出的良好的编程方法，为了代码可重用性、增加可维护性，让代码更容易被他人理解、保证代码可靠性。设计模式使代码编写真正工程化。</p><p> 我们学设计模式，是为了学习<strong>如何合理的组织我们的代码，如何解耦，如何真正的达到对修改封闭对扩展开放的效果</strong>，而不是去背诵那些类的继承模式，然后自己记不住，回过头来就骂设计模式把你的代码搞复杂了 。</p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ul><li>单一职责原则：每个类应该实现单一的职责，否则应该把类拆分。</li><li>里氏替换原则：任何基类可以出现的地方，子类一定可以出现。它是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</li><li>依赖倒转原则：这是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。</li><li>接口隔离原则：使用多个隔离的接口，比使用单个接口要好。每个接口不存在子类用不到却必须实现的方法，否则要将接口拆分。</li><li>迪米特法则（最少知道原则）：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统的功能模块相对独立。</li><li>合成复用原则：尽量使用合成/聚合方式，而不是使用继承。</li></ul><h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><p>设计模式分为三大类：</p><ul><li>创建型模式（5）<ul><li>工厂方法模式 </li><li>抽象工厂模式</li><li>单例模式 </li><li>建造者模式 </li><li>原型模式 （简单工厂模式）</li></ul></li><li>结构型模式：（7）<ul><li>代理模式</li><li>装饰器模式</li><li>适配器模式</li><li>外观模式</li><li>组合模式</li><li>享元模式</li><li>桥接模式</li></ul></li><li>行为型模式：（11）<ul><li>观察者模式</li><li>责任链模式</li><li>模板方法模式</li><li>策略模式</li><li>迭代子模式</li><li>命令模式</li><li>状态模式</li><li>备忘录模式</li><li>访问者模式</li><li>中介者模式</li></ul></li></ul><h3 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h3><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>简单工厂模式并不属于23种模式中的一种，但是还是很有必要了解一下。<br>简单工厂模式：有一个工厂类，在工厂类中进行判断，创建需要的功能类。</p><p>不必使用具体的功能类去创建该类的实例，创建实例的操作交给工厂类去完成。但是，当需要增加一个新的功能类的时候，就需要在工厂类中增加一个判断。</p><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法模式使一个类的实例化延迟到子类。</p><p>当新增加一个类的时候，不需要对工厂类进行修改，但是当新增一个功能类的时候，需要创建对应的工厂类。这样，就会创建过多的类，不如策略模式。</p><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>提供一个创建一系列相关或者相互依赖对象的接口，而无需指定它们具体的类。</p><p>抽象工厂模式是工厂方法模式的升级版本。它用来创建一组相关或者相互依赖的对象。<br>与工厂方法模式的区别：工厂方法模式针对的是一个产品等级结构，而抽象工厂模式针对的是多个产品等级结构。通常，一个产品结构表现为抽象类或者接口，抽象工厂模式所提供的产品衍生自不同的接口或者抽象类。</p><h5 id="工厂方法模式："><a href="#工厂方法模式：" class="headerlink" title="工厂方法模式："></a>工厂方法模式：</h5><p>一个抽象产品类，可以派生出多个具体产品类。<br>一个抽象工厂类，可以派生出多个具体工厂类。<br>每个具体工厂类，只能创建一个具体产品类的实例。</p><h5 id="抽象工厂模式："><a href="#抽象工厂模式：" class="headerlink" title="抽象工厂模式："></a>抽象工厂模式：</h5><p>多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。<br>一个抽象工厂类，可以派生出多个具体工厂类。<br>每个具体工厂类，可以创建多个具体产品类的实例。也就是创建一个产品家族下的多个产品。</p><p>例子：工厂可以生产鼠标和键盘，但是微软和罗技都有这两个产品。那么，微软和罗技就可以看成是两个产品族，分别由A工厂和B工厂生产各自的鼠标和键盘。A和B对应于抽象工厂，每个工厂生产的鼠标和键盘对应于工厂方法。<br>如果使用工厂方法模式，只要替换生成键盘的工厂方法就可以把键盘从罗技换到微软。<br>但是使用了抽象工厂模式，只要换家工厂，就可以同时换鼠标和键盘。如果需要的产品（鼠标 键盘..）有很多，使用抽象工厂模式一次性替换很方便。</p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>有懒汉和饿汉两种模式，同时要注意线程安全的写法。</p><p>应用：对于无状态的类使用单例模式，节省内存资源。<br>Servlet中的实例就是单例模式，但是是多线程。<br>Spring中创建的Bean对象默认是单例模式，这样就不用为每个请求创建一个实例对象，减少性能开销。但是Struts2中的Action是多例模式，针对每个请求都会创建一个实例，因此是线程安全的。</p><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p>将一个复杂对象的创建与它的表示分离，使得同样的创建过程可以创建不同的表示。</p><p>需要建造者，还需要一个指挥者，负责整体的构建算法，也就是如何去组合产品。</p><p>应用：一个类的各个组成部分的具体实现类或者算法经常变化，但是将它们组合在一起的算法却相对稳定。提供一种封装机制将稳定的组合算法于易变的各个组成部分隔离开来。</p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br>简单的说，就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。</p><p>应用：如Object中的clone方法，需要该类实现Cloneable接口，注意这是浅表复制。如果想实现深表复制，可以将引用的对象也实现Cloneable接口，重写clone方法；或采用序列化，也就是采用流的方式读入当前对象的二进制输入，再写出二进制数据对应的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 写入当前对象的二进制流 */</span>  </span><br><span class="line">ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();  </span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);  </span><br><span class="line">oos.writeObject(<span class="keyword">this</span>);  </span><br><span class="line"><span class="comment">/* 读出二进制流产生的新对象 */</span>  </span><br><span class="line">ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());  </span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);  </span><br><span class="line"><span class="keyword">return</span> ois.readObject();</span><br></pre></td></tr></table></figure><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>为其他对象提供一种代理，以控制对这个对象的访问。<br>代理对象和被代理对象需要实现相同的接口，这样代理类才能完成代理工作。</p><h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><p>动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。</p><p>装饰对象和被装饰对象需要实现共同的接口，这样可以层层装饰。<br>在客户端创建被装饰的对象，然后作为构造参数传给装饰对象。</p><p>应用：当系统需要新的功能，向旧的类中添加新的代码。<br>Java的IO中，BufferedReader(new InputStreamReader(System.in)就是一个装饰模式。</p><p>装饰模式与代理模式的区别：装饰模式关注于在一个对象上动态的添加方法，代理模式关注于控制对象的访问。对于客户端来说，代理模式中，客户端不需要知道被代理对象的信息，被代理的对象是在代理类中完成了一个实例的创建。而装饰模式中，需要在客户端中将原始对象作为一个参数传给装饰者模式。</p><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>将一个类的接口转换成用户希望的另外一种接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作。</p><p>适配器模式主要是希望复用一些现有的类，但接口与复用环境要求不一致的情况。</p><p>应用：系统的数据和行为都正确时，但是接口不符合，应该用适配器。</p><h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><p>为子系统的一组接口提供一致的界面，此模式定义了一个高层的接口，这个接口使得这一子系统更加容易使用。</p><p>应用：比如在MVC架构中，Action层 Service层和Dao层就是外观模式。Service层中的方法可能会需要多个Dao层中的方法结合使用，这样将这些方法封装起来，向Action层提供一系列简单的接口，使得Action层的代码更加简洁和清晰。<br>Tomcat中也使用了外观模式，Tomcat中的每个组件都要相互通信，但是不能将自己内部的数据过多的暴露给其他组件，使用外观模式进行隔离数据。实际上传递的是RequestFacade和ResponseFacade对象，只提供外部程序感兴趣的方法。</p><p>外观模式与代理模式的区别：<br>代理模式是代理一个单一的对象，而外观模式代表一个子系统。<br>组合模式<br>将对象组合成树形结构以表示 部分—整体的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><p>对于客户端来说，无需区分是操作的是树枝对象还是树叶对象。</p><p>应用：文件系统</p><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p>运用共享技术有效的支持大量细粒度的对象。</p><p>实现对象的共享，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。</p><p>FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，则返回已经存在的对象，如果没有，则创建一个新的对象。</p><p>应用：String类型就是享元模式，对象一旦创建，就不能改变，存放于常量池中。<br>数据库连接池，url driverClassName username password dbname这些对于每个连接来说都是一样的，所以适合用享元模式处理。通过连接池的管理，实现了数据库连接的共享，不需要每一次都创建新的连接，节省了数据库重新创建的开销，提升了系统的性能。</p><h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><p>将抽象部分与它的实现部分分离，使它们都可以独立的变化。</p><p>应用：在JDBC中，使用了桥接模式。对于应用程序而言，只要选择不同的驱动方式，就可以让程序操作不同的数据库，而无需更改应用程序，对于数据库而言，为数据库实现不同的驱动程序，并不会影响应用程序。</p><p>行为型模式</p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>也是发布—订阅模式，是一种一对多的依赖关系。让多个观察者对象同时监听某一个主题对象，这个主题对象发生变化时，会通知所有观察者对象，使得它们可以自动更新自己。</p><p>将一个系统分割成一系列相互合作的类有不好的作用，那就是需要维护相关对象间的一致性。不希望为了维护一致性而使各类紧密耦合，这样会给维护 扩展 重用带来不变。</p><p>应用：util库中有Observale和Observer接口，被观察对象集成Observable类，Watcher对象实现Observer接口。</p><p>Spring中的事件驱动模型是观察者模式的一个典型应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationEvent</span> <span class="keyword">extends</span> <span class="title">EventObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7099057708183571937L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestamp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.timestamp = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationEvent继承自jdk的EventObject,所有的事件都需要继承ApplicationEvent,并且通过source得到事件源.该类的实现类ApplicationContextEvent表示ApplicaitonContext的容器事件.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationListener继承自jdk的EventListener,所有的监听器都要实现这个接口,这个接口只有一个onApplicationEvent()方法,该方法接受一个ApplicationEvent或其子类对象作为参数,在方法体中,可以通过不同对Event类的判断来进行相应的处理.当事件触发时所有的监听器都会收到消息,如果你需要对监听器的接收顺序有要求,可是实现该接口的一个实现SmartApplicationListener,通过这个接口可以指定监听器接收事件的顺序.</p><p>事件机制需要事件源 事件 事件监听器。ApplicationEvent相当于事件， ApplicationListener相当于事件监听器，事件源是ApplicationContext。ApplicationContext是spring中的全局容器，负责读取bean的配置文档，管理bean的加载，维护bean之间的依赖关系。ApplicationContext作为一个事件源，需要显示的调用publishEvent方法，传入一个ApplicationEvent的实现类对象作为参数，每当ApplicationContext发布ApplicationEvent时，所有的ApplicationListener就会被自动触发。<br>ApplicationContext接口实现了ApplicationEventPublisher接口，里面有一个发布事件的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationEventPublisher</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们常用的ApplicationContext都继承了AbstractApplicationContext,像我们平时常见的ClassPathXmlApplicationContext、XmlWebApplicationContex也都是继承了它,AbstractApplicationcontext是ApplicationContext接口的抽象实现类,在该类中实现了publishEvent方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(event, <span class="string">"Event must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Publishing event in "</span> + getDisplayName() + <span class="string">": "</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">    getApplicationEventMulticaster().multicastEvent(event);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.parent.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中,我们看到了一个getApplicationEventMulticaster().这就要牵扯到另一个类ApplicationEventMulticaster.<br>ApplicationEventMulticaster属于事件广播器，作用就是把ApplicationContext发布的Event广播给所有的监听器。<br>在AbstractApplicationcontext中有一个applicationEventMulticaster的成员变量,提供了监听器Listener的注册方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">private</span> ApplicationEventMulticaster applicationEventMulticaster;</span><br><span class="line">　　<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Register statically specified listeners first.</span></span><br><span class="line">        <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">            getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">        <span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">        String[] listenerBeanNames = getBeanNamesForType(ApplicationListener<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (String lisName : listenerBeanNames) &#123;</span><br><span class="line">            getApplicationEventMulticaster().addApplicationListenerBean(lisName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合。将这些对象链接成一条链，并沿着这条链传递该请求，直到一个对象处理为止。</p><p>好处：请求是沿着链传递，直至有一个具体的处理者对象对其进行处理。这使得接收者和发送者都没有对方明确的信息，并且链中的对象也不知道链的结构。职责链可以简化对象之间的相互连接，仅需保持一个指向其后继者的调用，而不需要保持它所有的候选接收者的引用。</p><p>应用：Tomcat中的Filter使用了责任链模式。<br>Tomcat的容器设置也是责任链模式。Engine-Host-Context-Wrapper都是通过一个链传递请求。</p><h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><p>定义了一个操作中算法的骨架，而将一些步骤延迟到子类。模板方法使得子类可以不改变一个算法的结构就可以重新定义该算法的某些特定的步骤。</p><p>将不变的行为搬移到超类中，去除子类中的重复代码来体现它的优势。</p><p>应用：HttpServlet提供一个service方法，这个方法调用了7个do方法中的一个或者几个，完成对客户端的响应。这些do方法要求HttpServlet具体子类去实现。</p><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>定义了算法家族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化不会影响到使用算法的用户。</p><p>这些算法都是完成相同的工作，只是实现不同。</p><p>应用：需要在不同的时间点，应用不用的业务规则。（比如打折促销各种优惠手段）<br>迭代子模式<br>提供一种方法顺序的访问一个聚合对象中各个元素，而不是暴露该对象的内部表示。</p><p>应用：当需要访问一个聚集对象时，而且不管这些对象是什么就需要遍历的时候。<br>Java中的集合。</p><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>将一个请求封装为一个对象，从而使你可以用不同的请求对客户 进行参数化，对请求排队或者记录请求日志时，以及支持撤销的操作。</p><p>命令模式把发出命令的责任和执行命令的责任分割开来，委派给不同的对象。<br>优点：比较容易的设计一个请求队列。在需要的情况下，可以比较容易的将命令记入日志。<br>允许接收请求的一方决定是否要否决请求。比较容易的实现对请求的撤销和重做。</p><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><p>当一个对象的内存状态改变时，允许改变其行为。这个对象看起来是像改变了类。</p><p>当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到不同状态的一系列类当中，可以把复杂的判断逻辑简化。</p><p>应用：当一个对象的行为取决于它的状态时，并且它必须在运行时刻根据它的状态改变它的行为时，可以考虑使用。</p><h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p><p>应用：适应于功能比较复杂，但需要维护或记录属性历史的类。（游戏进度）</p><h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下，定义作用于这些元素的新操作。</p><p>应用：适应于数据结构相对稳定的系统。它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对的自由的演化。目的是把处理从数据结构中分离出来。如果系统中有比较稳定的数据结构，又有易于变化的算法，用访问者模式。</p><p>优点：增加新的操作很容易，只需要增加一个新的访问者。</p><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示的相互调用，从而使其耦合松散，而且可以独立的改变它们之间的交互。</p><p>中介对象需要知道所有的具体同事类，从具体同事类中接收消息，向具体同事发出命令。<br>具体同事类，每个具体同事只知道自己的行为，而不了解其他同事类的情况，但它们都认识中介对象。</p><p>优点：中介者模式减少了各个Colleage的耦合，使得可以独立的改变和复用各个Colleague类和Mediator。<br>缺点：交互的复杂性变为了中介者的复杂性，这使得中介者变得比任何一个类都复杂。</p><p>应用：应用于一组对象以定义良好但是复杂的方式进行通信的场合。以及想定制一个分布在多个类中而又不想生成太多子类的场合。</p><p>中介者模式与代理模式：<br>代理模式是一对一，这个代理只能代表一个对象。只能代理一方，比如PB是B的代理，A能够通过PB访问B，但是B不能通过PB访问A。（比如手机代理，我们只能通过手机代理去买手机）<br>中介者模式是多对多，这些被管理的对象之间都可以通信，它们的业务关系应该是交互在一起的。A可以通过中介访问B，B也能够通过中介访问A。（比如房屋中介，中介者有房源的信息也有客户的信息，可以双向进行通信）</p><h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><p>应用：如果一种特定类型的问题发生的频率足够高，那么就有可能值得将该问题的实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p><blockquote><p>参考CSDN博主「淹不死的水」的原创文章<br>原文链接：<a href="https://blog.csdn.net/stone_yw/article/details/69680916" target="_blank" rel="noopener">https://blog.csdn.net/stone_yw/article/details/69680916</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;六大设计原则与二十三种设计模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="//blog.qinbo.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计思想" scheme="//blog.qinbo.top/tags/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>github图床配置</title>
    <link href="//blog.qinbo.top/2020/05/27/github%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE/"/>
    <id>//blog.qinbo.top/2020/05/27/github图床配置/</id>
    <published>2020-05-27T06:08:33.000Z</published>
    <updated>2020-05-28T02:44:28.957Z</updated>
    
    <content type="html"><![CDATA[<p>如何用github搭建一个免费的图片存储仓库？</p><a id="more"></a><p>如果你有以下需求，用github搭建仓库可以帮你解决：</p><ul><li>用markdown写文章时，图片引用麻烦，希望能直接引用网络地址</li><li>希望能够随手存喜欢的图片</li><li>……</li></ul><blockquote><p>工欲善其事，必先利其器</p></blockquote><h3 id="1-架构"><a href="#1-架构" class="headerlink" title="1.架构"></a>1.架构</h3><p>使用Github配合PicGo，实现一键存图，一键返回网络地址</p><p>在这个过程中，github充当存储的角色，picgo实现自动化</p><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><p>我们站在巨人的肩膀上，两个工具都是已有的并且免费的，向前辈致敬！</p><h4 id="github配置"><a href="#github配置" class="headerlink" title="github配置"></a>github配置</h4><p>1.创建仓库（不用教吧）</p><p>2.生成token，token我理解是你用来和你自己的github仓库交互会话id，这个id有对应的权限，并且不会过期，相当于开的后门，以下是获取token的渠道【 账户/Settings/Developer settings/Personal access tokens 】</p><p><img src="https://raw.githubusercontent.com/qinbo1022/image_online/master/20200527143646.png" alt="获取token"></p><p>配置库权限，这里都勾上</p><p><img src="https://raw.githubusercontent.com/qinbo1022/image_online/master/20200527143948.png" alt="只需勾选库相关的权限即可"></p><p>只勾选库相关的权限，下一步就会获得到一个token，到这里github这一块就结束了</p><h4 id="picgo配置"><a href="#picgo配置" class="headerlink" title="picgo配置"></a>picgo配置</h4><p>1.下载一个picgo</p><p>2.配置图床地址</p><p><img src="https://raw.githubusercontent.com/qinbo1022/image_online/master/20200527144745.png" alt="配置地址"></p><p>3.配置快捷键</p><p><img src="https://raw.githubusercontent.com/qinbo1022/image_online/master/20200527150119.png" alt="快捷键设置"></p><p>也可以不配置，默认ctrl+shift+p</p><p>4.开启【上传后自动上传url到剪切板】</p><p>至此picgo的配置也结束了。</p><h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h3><p>工具已经配置好了，如何使用呢</p><p>1.截图，用qq微信或者自带的截图工具printScr都可以</p><p>2.上传，按下picgo的快捷键ctrl+shift+p一键上传</p><p>3.粘贴，ctrl+v不用教吧，粘贴出来的格式取决于你picgo配置的</p><p><img src="https://raw.githubusercontent.com/qinbo1022/image_online/master/20200527145448.png" alt="链接格式"></p><p>ps：github库推荐最大存储量是1G，最大容量是100G，超过75%的时候github会发出警告。</p><p>好了，教程就到这，好好利用，生命又多出一部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何用github搭建一个免费的图片存储仓库？&lt;/p&gt;
    
    </summary>
    
    
      <category term="图床" scheme="//blog.qinbo.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>kafka安装及使用</title>
    <link href="//blog.qinbo.top/2020/05/20/kafka%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>//blog.qinbo.top/2020/05/20/kafka安装及使用/</id>
    <published>2020-05-20T05:58:22.000Z</published>
    <updated>2020-06-04T10:08:00.481Z</updated>
    
    <content type="html"><![CDATA[<p>单机kafka的部署过程记录。</p><a id="more"></a><h3 id="一-下载"><a href="#一-下载" class="headerlink" title="一.下载"></a>一.下载</h3><p>本篇使用版本为</p><p>kafka_2.11-2.1.0</p><p>zookeeper-3.4.14</p><p>自行官网下载</p><h3 id="二-配置"><a href="#二-配置" class="headerlink" title="二.配置"></a>二.配置</h3><h4 id="zookeeper配置"><a href="#zookeeper配置" class="headerlink" title="zookeeper配置"></a>zookeeper配置</h4><p>zk是kafka的注册中心，先配置zk</p><h5 id="1-修改zoo-cfg（zoo-simple-cfg）"><a href="#1-修改zoo-cfg（zoo-simple-cfg）" class="headerlink" title="1. 修改zoo.cfg（zoo.simple.cfg）"></a>1. 修改zoo.cfg（zoo.simple.cfg）</h5><p>a）修改默认接口2181为2180，避免冲突</p><p>b）修改dataDir为自定义目录，此文件夹用于存放数据文件</p><p>c）新建dataLogDir为自定义目录 数据文件日志</p><p><strong>ps：必须填写绝对路径</strong></p><p><img src="https://raw.githubusercontent.com/qinbo1022/image_online/master/20200520195203.png" alt="test"></p><h5 id="2-启动zk并查看其状态"><a href="#2-启动zk并查看其状态" class="headerlink" title="2.启动zk并查看其状态"></a>2.启动zk并查看其状态</h5><p>进入bin目录，执行命令启动</p><blockquote><p>./zkServer.sh start</p></blockquote><p>启动成功后使用</p><blockquote><p>./zkServer.sh status</p></blockquote><p>查看启动状态</p><p><img src="https://raw.githubusercontent.com/qinbo1022/image_online/master/20200520195252.png" alt></p><h4 id="kafka配置"><a href="#kafka配置" class="headerlink" title="kafka配置"></a>kafka配置</h4><h5 id="1-配置server-properties"><a href="#1-配置server-properties" class="headerlink" title="1.配置server.properties"></a>1.配置server.properties</h5><p>a）创建数据存放目录</p><p>b）修改日志存放目录log.dirs</p><p>c）修改zookeeper的连接地址</p><p>d）修改默认端口端口</p><p><img src="https://raw.githubusercontent.com/qinbo1022/image_online/master/20200520195452.png" alt></p><p><img src="https://raw.githubusercontent.com/qinbo1022/image_online/master/20200520195512.png" alt></p><p><img src="https://raw.githubusercontent.com/qinbo1022/image_online/master/20200520195532.png" alt></p><h5 id="2-配置producer-properties"><a href="#2-配置producer-properties" class="headerlink" title="2.配置producer.properties"></a>2.配置producer.properties</h5><p><img src="https://raw.githubusercontent.com/qinbo1022/image_online/master/20200520195422.png" alt></p><h5 id="3-配置zookeeper-properties"><a href="#3-配置zookeeper-properties" class="headerlink" title="3.配置zookeeper.properties"></a>3.配置zookeeper.properties</h5><p><img src="https://raw.githubusercontent.com/qinbo1022/image_online/master/20200520195326.png" alt></p><h5 id="4-启动"><a href="#4-启动" class="headerlink" title="4.启动"></a>4.启动</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-<span class="keyword">server</span>-<span class="keyword">start</span>.sh config/<span class="keyword">server</span>.properties</span><br></pre></td></tr></table></figure><p>执行启动命令，指定配置文件【这一步建议放到tmux或nohup执行】</p><h3 id="三-测试"><a href="#三-测试" class="headerlink" title="三.测试"></a>三.测试</h3><h5 id="1-创建topic"><a href="#1-创建topic" class="headerlink" title="1.创建topic"></a>1.创建topic</h5><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">bin/kafka</span><span class="literal">-</span><span class="comment">topics</span><span class="string">.</span><span class="comment">sh</span> --<span class="comment">create</span> --<span class="comment">zookeeper</span> <span class="comment">localhost:2180</span> --<span class="comment">replication</span><span class="literal">-</span><span class="comment">factor</span> <span class="comment">1</span> --<span class="comment">partitions</span> <span class="comment">8</span> --<span class="comment">topic</span> <span class="comment">test_topic</span></span><br></pre></td></tr></table></figure><p>指定zk地址，副本数，分区数，topic名称</p><h5 id="2-查看topic"><a href="#2-查看topic" class="headerlink" title="2.查看topic"></a>2.查看topic</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --zookeeper <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">2180</span></span><br></pre></td></tr></table></figure><h5 id="3-启动一个控制台生产者和控制台消费者验证是否正常使用"><a href="#3-启动一个控制台生产者和控制台消费者验证是否正常使用" class="headerlink" title="3.启动一个控制台生产者和控制台消费者验证是否正常使用"></a>3.启动一个控制台生产者和控制台消费者验证是否正常使用</h5><ul><li><p>控制台生产者</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9090</span> --topic test_topic</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>控制台消费者(从头开始消费)</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9090</span> --topic test_topic --<span class="keyword">from</span>-beginning</span><br></pre></td></tr></table></figure></li></ul><h3 id="四-其他命令"><a href="#四-其他命令" class="headerlink" title="四.其他命令"></a>四.其他命令</h3><p>1.修改分区数</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-topics.sh --alter --zookeeper <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">2180</span> --topic test_topic --partitions <span class="number">8</span></span><br></pre></td></tr></table></figure><p>2.查看分区</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-topics.sh --describe --zookeeper <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">2180</span> --topic test_topic</span><br></pre></td></tr></table></figure><p><strong>PS: 提高分区数是提高并发的有效方式</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单机kafka的部署过程记录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kafka" scheme="//blog.qinbo.top/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>hexo的基本操作</title>
    <link href="//blog.qinbo.top/2019/11/11/hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>//blog.qinbo.top/2019/11/11/hexo基本操作/</id>
    <published>2019-11-11T09:49:50.000Z</published>
    <updated>2020-05-28T09:15:30.393Z</updated>
    
    <content type="html"><![CDATA[<p> hexo是一个很简洁的博客框架，拥有很多主题，很适合用作个人博客，在此记录一下基本用法。</p><p>官方文档地址： <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a> </p><a id="more"></a> <h3 id="1-创建一篇新文章"><a href="#1-创建一篇新文章" class="headerlink" title="1.创建一篇新文章"></a>1.创建一篇新文章</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> [layout] &lt;<span class="built_in">title</span>&gt;</span><br></pre></td></tr></table></figure><hr><p>参数</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span>： </span><br><span class="line">    post：要发表的文章，保存在<span class="keyword">source</span>/_posts目录下</span><br><span class="line">    page：要发表的文章，保存在<span class="keyword">source</span>下</span><br><span class="line">    draft：保存为草稿，保存在<span class="keyword">source</span>/_drafts下，草稿不会被发布,使用命令</span><br><span class="line">        $ hexo publish [<span class="keyword">layout</span>] &lt;title&gt;</span><br><span class="line">    可以发布&lt;title&gt;这份草稿</span><br><span class="line">title：文章标题</span><br></pre></td></tr></table></figure><h3 id="2-文章参数设置"><a href="#2-文章参数设置" class="headerlink" title="2.文章参数设置"></a>2.文章参数设置</h3><p><strong>Front-matter</strong></p><p>Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2013</span><span class="string">/7/13</span> <span class="number">20</span><span class="string">:46:25</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:center">描述</th><th style="text-align:right">默认值</th></tr></thead><tbody><tr><td style="text-align:left">layout</td><td style="text-align:center">布局</td><td style="text-align:right">post</td></tr><tr><td style="text-align:left">title</td><td style="text-align:center">标题</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">date</td><td style="text-align:center">建立日期</td><td style="text-align:right">文件建立日期</td></tr><tr><td style="text-align:left">updated</td><td style="text-align:center">更新日期</td><td style="text-align:right">文件更新日期</td></tr><tr><td style="text-align:left">comments</td><td style="text-align:center">开启文章的评论功能</td><td style="text-align:right">true</td></tr><tr><td style="text-align:left">tags</td><td style="text-align:center">标签（不适用于分页）</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">categories</td><td style="text-align:center">分类（不适用于分页）</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">permalink</td><td style="text-align:center">覆盖文章网址</td></tr></tbody></table><p><strong>分类和标签</strong></p><p>语法：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">categories: "test"</span><br><span class="line"><span class="keyword">tags:</span></span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure><p><strong>JSON Front-matter</strong></p><p>除了 YAML 外，也可以使用 JSON 来编写 Front-matter，只要将 — 代换成 ;;; 即可。如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"title"</span>: <span class="string">"Hello World"</span>,</span><br><span class="line"><span class="string">"date"</span>: <span class="string">"2013/7/13 20:46:25"</span></span><br><span class="line"><span class="comment">;;;</span></span><br></pre></td></tr></table></figure><h3 id="3-引用块"><a href="#3-引用块" class="headerlink" title="3.引用块"></a>3.引用块</h3><p><a href="https://hexo.io/zh-cn/docs/tag-plugins" target="_blank" rel="noopener">查看官方说明</a></p><h3 id="4-发布"><a href="#4-发布" class="headerlink" title="4.发布"></a>4.发布</h3><p><strong>1.生成静态文件</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">generate</span></span><br></pre></td></tr></table></figure><p>简写</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo g</span><br></pre></td></tr></table></figure><p><strong>2.清理生成的文件（防止缓存）</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo clean</span><br></pre></td></tr></table></figure><p><strong>3.启动服务</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">server</span></span><br></pre></td></tr></table></figure><p>默认启动端口为4000，访问地址<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><p>参数：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-p, <span class="comment">--port      重设端口</span></span><br><span class="line">-s, <span class="comment">--static 只使用静态文件</span></span><br><span class="line">-l, <span class="comment">--log      启动日记记录，使用覆盖记录格式</span></span><br></pre></td></tr></table></figure><p>也可简写为：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo s</span><br></pre></td></tr></table></figure><p><strong>4. 发布到网站</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo deploy</span><br></pre></td></tr></table></figure><p>简写：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo d</span><br></pre></td></tr></table></figure><h3 id="5-查看基本信息"><a href="#5-查看基本信息" class="headerlink" title="5.查看基本信息"></a>5.查看基本信息</h3><p><strong>1.list</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="built_in">list</span> &lt;type&gt;</span><br></pre></td></tr></table></figure><p>type可选参数：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">page,</span> post, route, tag, category</span><br></pre></td></tr></table></figure><p><strong>2.version</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="built_in">version</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; hexo是一个很简洁的博客框架，拥有很多主题，很适合用作个人博客，在此记录一下基本用法。&lt;/p&gt;
&lt;p&gt;官方文档地址： &lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hexo.io/zh-cn/docs/&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="//blog.qinbo.top/tags/hexo/"/>
    
  </entry>
  
</feed>
