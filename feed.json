{"title":"bobo的鬼屋","description":"Java后端Boy","language":"","link":"//blog.qinbo.top","pubDate":"Fri, 05 Jun 2020 06:41:35 GMT","lastBuildDate":"Fri, 05 Jun 2020 12:11:51 GMT","generator":"hexo-generator-json-feed","webMaster":"bobo","items":[{"title":"《小狗钱钱》读后总结","link":"//blog.qinbo.top/2020/06/05/小狗钱钱读后总结/","description":"《小狗钱钱》讲的是故事，是理财，也是人生。 【梦想存储罐和梦想相册】： 界定范围，让梦想在可及范围 自我激励，让未来触手可及 积跬步至千里，保持梦想鲜活度 【达瑞与表哥的故事】： 发现并抓住身边的机会 不要因为客观因素忘了需要坚持的事情","pubDate":"Fri, 05 Jun 2020 06:41:35 GMT","guid":"//blog.qinbo.top/2020/06/05/小狗钱钱读后总结/","category":"读后感"},{"title":"【ip地址、子网掩码、网关地址】浅析","link":"//blog.qinbo.top/2020/06/05/【ip地址、子网掩码、网关地址】浅析/","description":"1）IP地址 IP地址是TCP/IP协议为了唯一地确定一台主机的位置所定义的地址。 IP地址有效范围分为五类，A类保留给政府机构，B类分配给中等规模的公司，C类分配给任何需要的人，D类用于组播，E类用于实验： A类地址⑴ A类地址第1字节为网络地址，其它3个字节为主机地址。⑵ A类地址范围：1.0.0.1—126.155.255.254⑶ A类地址中的私有地址和保留地址：① 10.X.X.X是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址）。② 127.X.X.X是保留地址，用做循环测试用的。 B类地址⑴ B类地址第1字节和第2字节为网络地址，其它2个字节为主机地址。⑵ B类地址范围：128.0.0.1—191.255.255.254。⑶ B类地址的私有地址和保留地址① 172.16.0.0—172.31.255.255是私有地址② 169.254.X.X是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器。就会得到其中一个IP。 C类地址⑴ C类地址第1字节、第2字节和第3个字节为网络地址，第4个个字节为主机地址。另外第1个字节的前三位固定为110（二进制）。⑵ C类地址范围：192.0.0.1—223.255.255.254。⑶ C类地址中的私有地址：192.168.X.X是私有地址。 D类地址⑴ D类地址不分网络地址和主机地址，它的第1个字节的前四位固定为1110（二进制）。⑵ D类地址范围：224.0.0.1—239.255.255.254 E类地址⑴ E类地址也不分网络地址和主机地址，它的第1个字节的前五位固定为11110（二进制）。⑵ E类地址范围：240.0.0.1—255.255.255.254 2）子网掩码 子网掩码的作用是屏蔽部分ip地址和区分主机标识和网络标识，必须与IP一起使用，使用子网掩码可减少IP的浪费。 子网掩码是一串32位的二进制数字，由连续的1和连续的0组成，与IP一起使用，每一位都是对应关系，做&amp;运算，左边是网络位，由1组成，1的数量代表着网络位的长度，右边是主机位由0组成，0的数目即为主机位的长度。在与IP做与运算（&amp;）时，0可以遮住主机地址（&amp;运算，见下方）以达到屏蔽部分ip的目的。常用三类IP地址都有缺省子网掩码： 类别 子网掩码的二进制数值 子网掩码的十进制数值 A 11111111 00000000 00000000 00000000 255.0.0.0 B 11111111 11111111 00000000 00000000 255.255.0.0 C 11111111 11111111 11111111 000000000 255.255.255.0 两台计算机的IP地址与子网掩码做&amp;运算后，得出的网络位如果相同，则这两台计算机处于同一子网（网段） 企业可通过划分多个子网来解决ip资源不足的问题，但多个子网之间的通信则需要通过网关进行连接。 3）网关 网关是一种充当网络转换的计算机系统或设备，可以将不同的通信协议、数据格式或语言，乃至体系结构完全不同的两种系统之间进行翻译与转换，转换后的信息重新打包后通过网桥或交换机进行传达，以实现不同的网络互联，它的实质是一个网络通向另一个网络的IP地址。 通过上面的描述我们知道，是否同一网段是通过子网掩码和IP地址运算进行判定的，当两个网络之间没有路由器，是不可以进行TCP/IP协议通信的，要实现互通就必须通过网关，例如A网络与B网络不互通，如果A网络的主机发现目标主机不在本网络，他就把数据发送到自己的网关，再由网关转发给B网络的网关，B网络的网关再将数据发送给B网络的主机，在此过程中网关充当了路由器的角色，故也被称为“IP路由器”。 与运算规则：1&amp;1=1，0&amp;1=0，0&amp;0=0，即全1则得1，不全1则得0","pubDate":"Fri, 05 Jun 2020 05:59:39 GMT","guid":"//blog.qinbo.top/2020/06/05/【ip地址、子网掩码、网关地址】浅析/","category":"学习笔记"},{"title":"Google缓存框架GuavaCache","link":"//blog.qinbo.top/2020/06/05/Google缓存框架GuavaCache/","description":"what、why、how三部曲1.GuavaCache是什么？GuavaCache是Guava中的缓存框架，与ConcurrentMap很相似，不一样的是，ConcurrentMap中的元素会一直保留直到显式的移除，而GuavaCache为了限制内存占用，通常会设定为自动回收元素。 2.什么时候用GuavaCache?与传统的缓存方案相比，如redis，GuavaCache是将数据放在内存当中，访问起来更加高效，并且GuavaCache将很多常见的业务场景进行高度封装，使用起来非常灵活，对内存中的数据管理也有更多的方案。 Guava官网介绍，下面的这几种情况可以考虑使用Guava Cache： - 愿意消耗一些内存空间来提升速度。 - 预料到某些键会被多次查询。 - 缓存中存放的数据总量不会超出内存容量。 3.如何使用GuavaCache？1. 构建缓存对象 可以通过CacheBuilder类构建一个缓存对象，CacheBuilder采用builder设计模式，它的每个方法都返回CacheBuilder本身，直到build()方法被调用。构建一个对象的代码如下： 12345public void buildCache() &#123; Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(); cache.put(\"hello\", \"hello world\"); System.out.println(cache.getIfPresent(\"hello\"));&#125; 2. 设置最大存储量123456789101112public void buildCache() &#123; Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().maximumSize(3).build(); cache.put(\"hello\", \"hello world\"); System.out.println(cache.getIfPresent(\"hello\")); cache.put(\"hello1\", \"hello world1\"); cache.put(\"hello2\", \"hello world2\"); cache.put(\"hello3\", \"hello world3\"); System.out.println(cache.getIfPresent(\"hello\")); System.out.println(cache.getIfPresent(\"hello1\")); System.out.println(cache.getIfPresent(\"hello2\")); System.out.println(cache.getIfPresent(\"hello3\"));&#125; hello world null hello world1 hello world2 hello world3 3. 设置过期时间 expireAfterWrite是设置put到Cache的对象3秒过期，不论中间有没有被访问。 12345678public void buildCache() throws InterruptedException &#123; Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().expireAfterWrite(3, TimeUnit.SECONDS).maximumSize(3).build(); cache.put(\"hello\", \"hello world\"); for(int i=0;;i++)&#123; System.out.println(\"第\"+i+\"次获取key的值：\"+ cache.getIfPresent(\"hello\")); Thread.sleep(1000L); &#125;&#125; 第0次获取key的值：hello world 第1次获取key的值：hello world 第2次获取key的值：hello world 第3次获取key的值：null 第4次获取key的值：null 第5次获取key的值：null 第6次获取key的值：null expireAfterAccess是设置Cache中对象超过3秒没有被访问就会过期。 12345678public void buildCache() throws InterruptedException &#123; Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().expireAfterAccess(3, TimeUnit.SECONDS).maximumSize(3).build(); cache.put(\"hello\", \"hello world\"); for (int i = 0; ; i++) &#123; System.out.println(\"第\" + i + \"秒获取key的值：\" + cache.getIfPresent(\"hello\")); Thread.sleep(i * 1000L); &#125;&#125; 第0秒获取key的值：hello world 第1秒获取key的值：hello world 第2秒获取key的值：hello world 第3秒获取key的值：hello world 第4秒获取key的值：null 第5秒获取key的值：null 第6秒获取key的值：null 4. 显示清除 可以调用Cache的invalidateAll批量移除记录或者调用invalidate移除Cache中的一个记录，invalidateAll的参数是Iterable类型的，参数包含要删除的key值，当没有传入任何参数时，invalidateAll将移除Cache中所有的记录。 123456789101112131415161718public void buildCache() &#123; Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(); cache.put(\"hello1\",\"world1\"); cache.put(\"hello2\",\"world2\"); cache.put(\"hello3\",\"world3\"); cache.put(\"hello4\",\"world4\"); //cache.invalidate(\"hello2\"); List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"hello2\"); list.add(\"hello3\"); cache.invalidateAll(list); System.out.println(cache.getIfPresent(\"hello1\")); System.out.println(cache.getIfPresent(\"hello2\")); System.out.println(cache.getIfPresent(\"hello3\")); System.out.println(cache.getIfPresent(\"hello4\"));&#125; world1 null null world4 5. 移除监听器12345678910public void buildCache() &#123; RemovalListener&lt;String, String&gt; listener = removalNotification -&gt; System.out.println(removalNotification.getKey() + \":\" + removalNotification.getValue() + \" is removed\"); Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().removalListener(listener).maximumSize(3).build(); cache.put(\"hello1\", \"world1\"); cache.put(\"hello2\", \"world2\"); cache.put(\"hello3\", \"world3\"); cache.put(\"hello4\", \"world4\"); cache.put(\"hello5\", \"world5\");&#125; hello1:world1 is removed hello2:world2 is removed 以上列举了GuavaCache常用几种方法，源码请移步下方地址获取： https://github.com/google/guava","pubDate":"Fri, 05 Jun 2020 05:56:14 GMT","guid":"//blog.qinbo.top/2020/06/05/Google缓存框架GuavaCache/","category":"学习笔记,Guava"},{"title":"React学习-day02","link":"//blog.qinbo.top/2020/06/03/React学习-day02/","description":"React学习day02。","pubDate":"Wed, 03 Jun 2020 05:40:40 GMT","guid":"//blog.qinbo.top/2020/06/03/React学习-day02/","category":"React,学习笔记"},{"title":"React学习 - day1","link":"//blog.qinbo.top/2020/06/02/React学习-day01/","description":"React学习day01。","pubDate":"Tue, 02 Jun 2020 02:51:45 GMT","guid":"//blog.qinbo.top/2020/06/02/React学习-day01/","category":"React,学习笔记"},{"title":"设计模式之建造者模式（1/23）","link":"//blog.qinbo.top/2020/05/29/设计模式之建造者模式（1-23）/","description":"建造者模式浅析。","pubDate":"Fri, 29 May 2020 08:11:08 GMT","guid":"//blog.qinbo.top/2020/05/29/设计模式之建造者模式（1-23）/","category":"设计模式"},{"title":"设计原则与设计模式","link":"//blog.qinbo.top/2020/05/27/设计原则与设计模式/","description":"六大设计原则与二十三种设计模式。","pubDate":"Wed, 27 May 2020 10:08:33 GMT","guid":"//blog.qinbo.top/2020/05/27/设计原则与设计模式/","category":"设计模式,设计思想"},{"title":"github图床配置","link":"//blog.qinbo.top/2020/05/27/github图床配置/","description":"如何用github搭建一个免费的图片存储仓库？","pubDate":"Wed, 27 May 2020 06:08:33 GMT","guid":"//blog.qinbo.top/2020/05/27/github图床配置/","category":"图床"},{"title":"kafka安装及使用","link":"//blog.qinbo.top/2020/05/20/kafka安装及使用/","description":"单机kafka的部署过程记录。","pubDate":"Wed, 20 May 2020 05:58:22 GMT","guid":"//blog.qinbo.top/2020/05/20/kafka安装及使用/","category":"kafka"},{"title":"hexo的基本操作","link":"//blog.qinbo.top/2019/11/11/hexo基本操作/","description":"hexo是一个很简洁的博客框架，拥有很多主题，很适合用作个人博客，在此记录一下基本用法。 官方文档地址： https://hexo.io/zh-cn/docs/","pubDate":"Mon, 11 Nov 2019 09:49:50 GMT","guid":"//blog.qinbo.top/2019/11/11/hexo基本操作/","category":"hexo"}]}