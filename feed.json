{"title":"bobo的鬼屋","description":"Java后端Boy","language":"","link":"//blog.qinbo.top","pubDate":"Fri, 29 May 2020 08:11:08 GMT","lastBuildDate":"Fri, 29 May 2020 11:34:35 GMT","generator":"hexo-generator-json-feed","webMaster":"bobo","items":[{"title":"设计模式之建造者模式（1/23）","link":"//blog.qinbo.top/2020/05/29/设计模式之建造者模式（1-23）/","description":"建造者模式 一、what什么是建造者模式？ 造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式属于对象创建型模式。建造者模式又可以称为生成器模式。 二、why为什么要用建造者模式? 软件开发过程中，存在一些复杂的对象，它们拥有一系列成员属性，而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。 这些情况的存在导致复杂对象初始化变得非常麻烦，于是建造者模式应运而生，建造者模式将复杂的构建过程封装起来，暴露出建造的动作， 用户无须关心该对象所包含的属性以及它们的组装方式，这就是为什么要使用建造者模式的原因。 三、how如何使用？在什么情况下使用？ 带着问题开始阅读~ 1.角色组成建造者模式包含以下角色： Builder: 抽象建造者 ConcreteBuilder：具体建造者 Director：导演者 Product：产品 2.代码实现a).场景模拟 现有一个需求，建造一栋乡间别墅，请到了一支建筑团队，这时的角色组成可以带入到建造者模式中： 产品：别墅 导演：包工头 抽象建造者：施工员 具体建造者：农民工 b).工作拆分 首先产品确定产品内容： 别墅在建造过程中分为四部分： 打地基 筑墙 盖楼板 封顶 1234567891011@Datapublic class Product &#123; //打地基 private String base; //墙壁 private String wall; //楼板 private String board; //封顶 private String top;&#125; 施工员要画哪些图纸，也就是抽象建造： 1234567891011121314151617//图纸public interface drawing &#123; //建造地基 void buildBase(); //建造墙壁 void buildWall(); //建造楼板 void buildBoard(); //建造屋顶 void buildTop(); //验收产品 Product getResult();&#125; 农名工建造的内容： 12345678910111213141516171819202122232425262728293031323334//建造者根据图纸内容建造，这里是复杂的构建过程，代码只是举例@Slf4jpublic class Worker implements Drawing &#123; Product product = new Product(); @Override public void buildBase() &#123; log.debug(\"过程：采用xxx技术打造坚固的地基\"); product.setBase(\"地基\"); &#125; @Override public void buildWall() &#123; log.debug(\"过程：采用xxx材料建起最好的墙壁\"); product.setWall(\"墙壁\"); &#125; @Override public void buildBoard() &#123; log.debug(\"过程：采用xxx材料打造最厚实的楼板\"); product.setBoard(\"楼板\"); &#125; @Override public void buildTop() &#123; log.debug(\"过程：采用xxx过程建造最好楼顶\"); product.setTop(\"楼顶\"); &#125; @Override public Product getResult() &#123; return product; &#125;&#125; 包工头的工作： 123456789101112131415161718//包工头public class Contractor &#123; private Drawing drawing; //构造方法，拿到图纸 public Contractor(Drawing drawing) &#123; this.drawing = drawing; &#125; //监督每个部分的建造 public void construct() &#123; drawing.buildBase(); drawing.buildBoard(); drawing.buildTop(); drawing.buildWall(); &#125;&#125; c).实际建造 1234567891011121314151617@Slf4jpublic class test &#123; public static void main(String[] args) &#123; //农民工拿到图纸 Drawing drawing = new Worker(); //包工头喊农名工兄弟过来 Contractor contractor = new Contractor(drawing); //包工头开始指挥建造 contractor.construct(); //建造完毕，拿到根据图纸产出的别墅 Product product = drawing.getResult(); log.info(\"别墅地基：&#123;&#125;\",product.getBase()); log.info(\"别墅墙壁：&#123;&#125;\",product.getWall()); log.info(\"别墅楼板：&#123;&#125;\",product.getBoard()); log.info(\"别墅屋顶：&#123;&#125;\",product.getTop()); &#125;&#125; 对于客户来说他只需告诉包工头我要建什么样的别墅，就能得到结果，无需关注过程。 在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。 通过上面的案例我们可以得出大致的结论： 在以下情况下可以使用建造者模式： 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。 对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。","pubDate":"Fri, 29 May 2020 08:11:08 GMT","guid":"//blog.qinbo.top/2020/05/29/设计模式之建造者模式（1-23）/","category":"设计模式"},{"title":"设计原则与设计模式","link":"//blog.qinbo.top/2020/05/27/设计原则与设计模式/","description":"六大设计原则与二十三种设计模式。","pubDate":"Wed, 27 May 2020 10:08:33 GMT","guid":"//blog.qinbo.top/2020/05/27/设计原则与设计模式/","category":"设计模式,设计思想"},{"title":"github图床配置","link":"//blog.qinbo.top/2020/05/27/github图床配置/","description":"如何用github搭建一个免费的图片存储仓库？","pubDate":"Wed, 27 May 2020 06:08:33 GMT","guid":"//blog.qinbo.top/2020/05/27/github图床配置/","category":"图床"},{"title":"kafka安装及使用","link":"//blog.qinbo.top/2020/05/20/kafka安装及使用/","description":"单机kafka的部署过程记录。","pubDate":"Wed, 20 May 2020 05:58:22 GMT","guid":"//blog.qinbo.top/2020/05/20/kafka安装及使用/","category":"kafka"},{"title":"hexo的基本操作","link":"//blog.qinbo.top/2019/11/11/hexo基本操作/","description":"hexo是一个很简洁的博客框架，拥有很多主题，很适合用作个人博客，在此记录一下基本用法。 官方文档地址： https://hexo.io/zh-cn/docs/","pubDate":"Mon, 11 Nov 2019 09:49:50 GMT","guid":"//blog.qinbo.top/2019/11/11/hexo基本操作/","category":"hexo"}]}